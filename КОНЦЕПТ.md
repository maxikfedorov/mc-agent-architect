Реализована и исследована концепция автономного
Minecraft‑агента‑строителя, который воспринимает игровой мир в виде
текстового состояния, самостоятельно планирует действия и генерирует код
 для их выполнения. Агент выступает как инженер‑архитектор: он получает
свободно сформулированные задачи игрока (от простых «построй дом» до
сложных «сделай пирамиду, мост, храм, деревья, научные структуры вроде
ДНК и графиков функций»), строит внутренний план (reasoning), разбивает
задачу на этапы и порождает исполняемый код, который преобразует
высокоуровневые архитектурные и научные описания в конкретные структуры в
 игровом мире.

Технически
 система представляет собой связку локальной языковой модели (через
OpenAI‑совместимый API) и бота Mineflayer, объединённых через протокол
инструментов: текстовый диалог и состояние мира подаются в промпт,
модель возвращает вызовы функций, основная из которых исполняет
сгенерированный асинхронный JavaScript‑код в ограниченной «песочнице» с
доступом только к высокоуровневым примитивам (`placeBlock`, `placeBlockAbsolute`, `giveMe`
 и др.). Архитектура включает отдельные модули для системного промпта,
описаний инструментов, диспетчера вызовов действий и специализированного
 «архитектора», реализующего безопасное выполнение кода, синхронизацию
операций с инвентарём (mutex), управление координатами (относительными и
 абсолютными) и шаблон короткой истории диалога для контекста; вся
связка работает поверх Node.js и экосистемы
mineflayer/pathfinder/creative‑плагинов.

---



## 1. Code-as-Policies (CaP)

Это **главный концепт** твоей системы. Вместо того чтобы предсказывать следующее действие (нажми "W"), модель пишет  *программу* , которая выполняет задачу.

* **Суть:** Использование генерации кода для управления роботами/агентами. Код выразительнее, чем одиночные команды.
* **Ключевая работа (Google DeepMind):**  *"Code as Policies: Language Model Programs for Embodied Control"* .[](https://arxiv.org/html/2402.19299v1)
* 
* **Почему это про тебя:** Твой агент генерирует асинхронный JS-код. Ты буквально реализовал CaP.

## 2. Voyager (Самый близкий аналог)

Если твой проект — это "Давид", то Voyager — это "Голиаф", на которого ты ориентируешься.

* **Суть:** Агент в Minecraft, который пишет код на JS (Mineflayer!), собирает библиотеку навыков и учится всю жизнь.
* **Ключевая работа:** *"Voyager: An Open-Ended Embodied Agent with Large Language Models"* (Wang et al., 2023).[](https://voyager.minedojo.org)
* 
* **Чем ты отличаешься:** Voyager фокусируется на *открытии* мира (Curiosity). Твой агент (судя по описанию) фокусируется на *сложном структурном строительстве* и *архитектурном планировании* (Creative Construction). Ты — "Voyager для Инженерии/Архитектуры".

## 3. GITM (Ghost in the Minecraft)

Это твой "Архитектор".

* **Суть:** Агент, который использует  **иерархическое планирование** . Он делит задачу «Добыть алмаз» на «Добыть дерево» -> «Сделать кирку» -> «Найти пещеру».
* **Ключевая работа:** *"Ghost in the Minecraft: Generally Capable Agents for Open-World Environments via Large Language Models"* (Zhu et al., 2023).[](https://openreview.net/pdf?id=cTOL99p5HL)
* 
* **Почему это про тебя:** Твой модуль "Архитектор", разбивающий задачу на этапы, реализует именно методологию GITM (Decomposition).

## 4. Programmatic Grounding (Программное заземление)

Термин для описания того, как слова превращаются в действия.

* **Суть:** Перевод естественного языка в исполняемый код в контексте среды.
* **Связанные работы:** Проекты типа **ViperGPT** или  **ProgPrompt** .
* **Идея для тебя:** Ты используешь LLM не как "болтушку", а как транслятор `Natural Language -> API Calls`.

## 5. Tool-Augmented Learning (TAL)

* **Суть:** Агент не пытается делать всё сам (нейросетью), а использует внешние инструменты (функции `placeBlock`, `pathfinder`).
* **Почему это важно:** Это показывает, что ты понимаешь ограничения LLM (она не может "руками" кликать мышкой) и решаешь их инженерно.
